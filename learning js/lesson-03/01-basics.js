/*
 * Знакомство  с массивами
 * - Объявление
 * - Индексация
 * - Длина
 * - Индекс последнего элемента
 * - Переопределение
 *
 * 'Mango', 'Kiwi', 'Poly', 'Ajax'
 */
// Массив это набор ячеек в памяти, сложный тип
//  * - Объявление

const friends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
// всегда const потому что меняется не сама переменная а массив
// console.log(friends); // через console.log() можно выводить, но лучше через console.table()---> выведет в виде табл с индексом и значением
console.log(friends.length); // свойство length выводит длину массива
console.table(friends);

// индекс массива всегда считантся length - 1;
const lastIndex = friends.length - 1;
console.log(lastIndex); // пример если нужно взять последнее значение в массиве

friends[0]; // если нужно обратится к определенному элементу массива, где friends название переменной(массивва) [index]
console.log(friends[1]); // вывдет Kiwi
console.log(friends[3]); // вывдет Ajax
console.log(friends[4]); //если поставить индекс больше чем елементов, выведет undefined

// Изминение элемента в масиве
// меняется не переменная а массив(изминение кусочка памяти в массиве)
friends[1] = 'Potato';
friends[3] = 1700;
console.table(friends);

/*
 * Передача по ссылке и по значению
 * - Примитивы и сложные типы
 * - Ссылочное равенство (referential equality)
 */
// Передача по значению  - делается точная копия, которые никак не связаны
// приметивный тип - работает со строками, числами, null, indefined
// передача по значению - это делается копия, отдельная ячейка в памяти и туда происходит копирывание и при обновлении допустим одной ячейки
// вторая не обновляется автоматически, это копии которые абсолютно друг от друга не зависят
// Что происходит - когда мы делаем переменную а, выделяется место в памяти в которую записываеться значение(в данном случаее 10), можно сказать что переменная и значение лежит в одно ячейке
//  когда делаем переменную b = а, то создается новая ячейка в памяти, в которую делается копия текущего значения (в данном случаее 10)
let a = 10;
const b = a;
console.log(a);
console.log(b);

// Если потом перезаписать переменную а, то в той ячейке памяти где хранится а запишится новое значение, а в переменной b останется старое значение (это копия старого значения),
//     так как это 2 разные ячейки
a = 20;

console.log(a);
console.log(b);


/* Ссылочное равенство (referential equality) - работает только со сложными типами (массив, функция, обьект) 
----> когда присваиваем сложные типы происходит перенаправление указателя ----> две разных переменных будут указывать на одно и тоже место в памяти, 
в данном примере массив. В переменных будет хранится указатель */
/* В пеменную с ложим сложный тип(массив), в этом случае происходит следующее ---> когда создается сложный тип(массив, функция, обьект)
под нее отдельно выделяется место в памяти, где лежит(в данном примере) массив[1, 2, 3], после чего создается переменная(с) и внутри
этой ячейки(где хранится переменная с) хранится не сам массив, а то что называется указатель(или ссылка). 
что происходит когда переменной d присваиваем значение с-- -> в новую ячейку памяти где будет лежать переменная d
копируется ссылка на массив, а не сам массив, то есть в переменной с и d лежит один и тот же массив */

const c = [1, 2, 3];
const d = c;

console.log('c', c);
console.log('d', d);

c[0] = 500; // перезапишет елемент с нулевым индексом как в перенной с так и d, это один и тот же массив

console.log('c', c);
console.log('d', d);

console.log(c === d); // выведет true, потому что один и тот же массив сравнивается с собой(так как a и d ссылаются на туже ячейку в памяти(один и тот же массив))
/* НО НА САМОМ деле СЛОЖНЫЕ ТИПЫ НЕ РАВНЫ друг другу!!!! Если сравнит 2 масива с одниковыми елементами, то это как сравнить две разных
ячейки в памяти */

console.log([1, 2, 3] === [1, 2, 3]); // выведет false, так как это две разных ячейки в памяти

// В сложных типах происхрдит сравнение по адресу в памяти, не по значению как приметивных типах

/*
 * Перебор (итерация) массива
 * - for - если нужен индекс или нужно изменить элемент массива
 * - for...of - если индекс не нужен и в массиве ничего менять не нужно
 */
// Если нужно каждый елемент вывести по отдельности используем цикл (тут for как пример, лучше использовать цикл for ... of)

// const newFriends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
// const newLastIndex = friends.length - 1;

// for (let i = 0; i <= newLastIndex; i += 1) {
//     console.log(newFriends[i]);
// }

// newFriends[i] - обращение к каждому элементу массива на итерации

// Изменяем элемент массива:
// Если нужно получить доступ к индексу или изменить значение элемента используем цикл for

const newFriends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
const newLastIndex = friends.length - 1;

for (let i = 0; i <= newLastIndex; i += 1) {
// newFriends[i] += '-1';// буквально обращение к ячейки памяти, дописывает к каждому элементу -1
newFriends[i] += `-${ i }`; // дописывает к каждому элементу - 0, -1, -2, -3;
}
console.table(newFriends);

/* Если не нужно получать доступ к индексу или изменять значение элемента используем цикл for of
for of ----> перебирает итерирумые обьекты (массивы, строки)
синтаксис----> for (const variable of iterable) {}
const (или let) - локальная переменная которая доступна только в этих скобках, название переменной долно быть в одиночном числе(
    если friends то friend
    если clients то client
)
variable - элемент итерируемого обьекта
iterable - сам обьект (что перебирается) */

// const newFriends = ['Mango', 'Kiwi', 'Poly', 'Ajax'];
// for (const newFriend of newFriends) { 
//     console.log(newFriend);
// }

 

// В отличии от for меньше синтаксиса